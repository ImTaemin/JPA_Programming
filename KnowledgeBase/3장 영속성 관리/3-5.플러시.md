# 🎈 플러시   
[1. 플러시 모드 옵션](#1-플러시-모드-옵션)   

**플러시(`flush()`)는 영속성 컨텍스트의 변경 내용을 DB에 반영한다.**   

### 플러시 실행시 일어나는 일   
1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다.   
수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
2. 쓰기 지연 SQL 저장소의 쿼리를 DB에 전송한다.(등록, 수정, 삭제)

### 영속성 컨텍스트를 플러시하는 방법   
- `em.flush()`를 직접 호출   
엔티티 매니저의 `flush()` 메소드를 직접 호출해서 영속성 컨텍스트를 강제로 플러시한다.   
*테스트나 다른 프레임워크와 JPA를 함께 사용시를 제외하고 거의 사용하지 않는다.*

- 트랜잭션 커밋 시 플러시 자동 호출   
DB에 변경 내용을 SQL로 전달하지 않고 트랜잭션만 커밋하면 어떤 데이터도 DB에 반영되지 않는다.   
트랜잭션을 커밋하기 전에 꼭 플러시를 호출해서 영속성 컨텍스트의 변경 내용을 DB에 반영해야 한다.   
<u>*JPA는 이런 문제를 예방하기 위해 트랜잭션 커밋 시 자동으로 플러시를 호출한다.*</u>   

- JPQL 쿼리 실행 시 플러시 자동 호출   
`JPQL`이나 `Criteria`같은 객체지향 쿼리를 호출할 때도 플러시가 실행된다.   
```java
//영속성 컨텍스트에 있지만 아직 DB에 반영되지 않은 상태
em.persist(memberA);
em.persist(memberB);
em.persist(memberC);

//중간에 JPQL 실행
query = em.createQuery("SELECT m FROM Member m", Member.class);
List<Member> members = query.getResultList();
```
JPQL을 실행하면 SQL로 변환되어 DB에서 엔티티를 조회하는데 memberA,B,C 엔티티가 없으므로 조회가 되지 않는다.   
따라서 쿼리를 실행하기 직전에 영속성 컨텍스트를 플러시해서 변경 내용을 DB에 반영해야 한다.   
<u>*JPA는 이런 문제를 예방하기 위해 JPQL을 실행할 때도 자동으로 플러시를 호출한다.*</u>   
❗식별자를 기준으로 조회하는 `find()`를 호출할 때는 플러시가 실행되지 않음.   

## 1. 플러시 모드 옵션   
엔티티 매니저에서 플러시 모드를 직접 지정하려면   
`javax.persistence.FlushModeType`을 사용하면 된다.   
- `FlushModeType.AUTO` : 커밋이나 쿼리를 실행할 때 플러시(기본값)
- `FlushModeType.COMMIT` : 커밋할 때만 플러시(성능 최적화 시 사용)   

플러시 모드 직접 설정 : `em.setFlushMode(FlushModeType.COMMIT)`   
플러시라는 이름으로 인해 ~~영속성 컨텍스트에 보관된 엔티티를 지운다고 생각하면 안 된다.~~   
**영속성 컨텍스트의 변경 내용을 DB에 동기화**하는 것이 **플러시**이다.   
트랜잭션이라는 작업 단위가 있기 때문에 DB와 동기화를 최대한 늦추는 것이 가능하다. (커밋 직전에만 동기화 하면 됨)