# ✔ 프록시 심화 주제

- [1. 영속성 컨텍스트와 프록시](#1-영속성-컨텍스트와-프록시)
- [2. 프록시 타입 비교](#2-프록시-타입-비교)
- [3. 프록시 동등성 비교](#3-프록시-동등성-비교)
- [정리](#📝-정리)

프록시는 원본 엔티티를 상속받아서 만들어지므로 엔티티를 사용하는 클라이언트는 엔티티가 프록시인지 원본 엔티티인지 구분하지 않고 사용할 수 있다.  
따라서 원본 엔티티를 사용하다가 지연 로딩을 하려고 프록시로 변경해도 클라이언트의 비즈니스 로직을 수정하지 않아도 된다.   
하지만 프록시를 사용하는 방식의 기술적인 한계로 인해 예상하지 못한 문제들이 발생하기도 한다.

## 1. 영속성 컨텍스트와 프록시
영속성 컨텍스트는 자신이 관리하는 영속 엔티티의 동일성을 보장한다.   
프록시로 조회한 엔티티의 동일성도 보장할까?
```java
@Test
public void persistContextAndProxy(){
    Member newMember = new Member("member1", "회원1");
    em.persist(newMember);
    em.flush();
    em.clear();

    Member refMember = em.getReference(Member.class, "member1");
    Member findMember = em.find(Member.class, "member1");

    System.out.println("refMember Type = " + refMember.getClass());
    System.out.println("findMember Type = " + findMember.getClass());

    Assert.assertTrue(refMember == findMember); //성공
}
```
출력 결과   
```
refMember Type = class jpabook.advanced.Member_$$_jvst843_0
findMember Type = class jpabook.advanced.Member_$$_jvst843_0
```

먼저 member1을 `em.getReference()`를 사용해 프록시로 조회했다.   
다음으로 같은 member1을 `em.find()`를 사용해 조히했다.   
`refMember`는 프록시고 `findMember`는 원본 엔티티이므로 서로 다른 인스턴스로 생각할 수 있지만 이렇게 되면 영속성 컨텍스트가 영속 엔티티의 동일성을 보장하지 못하는 문제가 발생한다.  

그래서 영속성 컨텍스트는 프록시로 조회된 엔티티에 대해서 같은 엔티티를 찾는 요청이 오면 원본 엔티티가 아닌 처음 조회된 프록시를 반환한다.   
코드에서 member1 엔티티를 프록시러 처음 조회했기 때문에 이후에 `em.find()`를 사용해서 같은 member1을 찾아도 영속성 컨텍스트는 원본이 아닌 프록시를 반환한다.   
출력 결과를 보면 `$$_jvst843_0`이 붙어있으므로 프록시로 조회된 것을 확인할 수 있다. 그리고 마지막에 `assertTrue` 검증 코드를 통해 둘이 같은 인스턴스인 것을 알 수 있다.   

따라서 프록시로 조회해도 영속성 컨텍스트는 영속 엔티티의 동일성을 보장한다.

```java
//원본 먼저 조회하고 나서 프록시로 조회
@Test
public void persistContextAndProxy2(){
    Member newMember = new Member("member1", "회원1");
    em.persist(newMember);
    em.flush();
    em.clear();

    Member findMember = em.find(Member.class, "member1");
    Member refMember = em.getReference(Member.class, "member1");

    System.out.println("refMember Type = " + refMember.getClass());
    System.out.println("findMember Type = " + findMember.getClass());

    Assert.assertTrue(refMember == findMember); //성공
}
```
```
출력 결과
refMember Type = class jpabook.advanced.Member
findMember Type = class jpabook.advanced.Member
```
**원본 엔티티를 먼저 조회하면 영속성 컨텍스트는 원본 엔티티를 이미 DB에서 조회했으므로 프록시를 반환할 이유가 없다.**   
따라서 `em.getReference()`를 호출해도 프록시가 아닌 원본을 반환한다. 물론 이 경우에도 영속성 컨텍스트는 자신이 관리하는 영속 엔티티의 동일성을 보장한다.

## 2. 프록시 타입 비교
프록시는 원본 엔티티를 상속 받아서 만들어지므로 프록시로 조회한 엔티티의 타입을 비교할 때는 `==` 비교를 하면 안 되고 `instanceof`를 사용해야 한다.   
<div style="margin:auto;background-color:white; width:50%; height:100%; display:flex; flex-direction:column; color:black; font-size:26px;border:1px solid black;">
    <div style="text-align:center" width="200" height="200">
        Member
    </div>
    <div style="text-align:center" height="100%">
        <svg width="100%" height="100%" style="transform:rotate(270deg)">
            <defs>
                <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="#000"/> 
            </defs> 
            <line x1="40%" y1="50%" x2="55%" y2="50%" stroke="#000" stroke-width="2" marker-end="url(#arrow)" />
        </svg>
    </div>
    <div style="text-align:center" height="200">
        Member_$$_jvsteXXX
    </div>
</div>

```java
@Test
public void compareProxyType(){
    Member newMember = new Member("member1", "회원1");
    em.persist(newMember);
    em.flush();
    em.clear();

    Member refMember = em.getReference(Member.class, "member1");

    Assert.assertFalse(Member.class == refMember.getClass()); //false
    Assert.assertTrue(refMember instanceof Member);           //true
}
```
```
출력 결과
refMember Type = class jpabook.advanced.Member_$$_jvstXXX
```
`refMember`의 타입을 출력해보면 프록시로 조회했으므로 출력 결과 끝에 프록시라는 의미의 `_$$_jvstXXX`가 붙어 있는 것을 확인할 수 있다.   

`Member.class == refMember.getClass()` 비교는 부모 클래스와 자식 클래스를 `==` 비교한 것이 된다. 따라서 결과는 false다.   
**프록시는 원본 엔티티의 자식 타입**이므로 `instanceof` 연산을 사용하면 된다.

## 3. 프록시 동등성 비교
엔티티의 동등성을 비교하려면 비즈니스 키를 사용해서 `equals()` 메소드를 오버라이딩하고 비교하면 된다.   
그런데 IDE나 외부 라이브러리를 사용해서 구현한 `equals()` 메소드로 엔티티를 비교할 때, 비교 대상이 원본 엔티티면 문제가 없지만 프록시면 문제가 발생할 수 있다.
```java
@Entity
public class Member{

    @Id
    private String id;
    private String name;
    ...

    @Override
    public boolean equals(Object obj){
        if(this == obj) return true;
        if(obj == null) return false;
        if(this.getClass() != obj.getClass()) return false; //...1

        Member member = (Member) obj;

        // ...2
        if(name != null ? !name.equals(member.name) : member.name != null){
            return false;
        }

        return true;
    }

    @Override
    public int hashCode(){
        return name != null ? name.hashCode() : 0;
    }
}
```
회원 엔티티는 name 필드를 비즈니스 키로 사용해서 `equals()` 메소드를 오버라이딩했다.(name이 중복x 가정)
```java
@Test
public void compareProxyEquiv(){
    Member saveMember = new Member("member1", "회원1");
    em.persist(saveMember);
    em.flush();
    em.clear();

    Member newMember = new Member("member1", "회원1");
    Member refMember = em.getReference(Member.class, "member1");

    Assert.assertTrue(newMember.equals(refMember));
}
```
<p align="center"><img src="https://i.ibb.co/vzVk4dy/image.png" width="60%"/><br>프록시 동등성 비교</p>

새로 생성한 회원 `newMember`와 프록시로 조회한 회원 `refMember`의 `name` 속성은 둘 다 회원1로 같으므로 동등성 비교를 하면 성공할 것 같다. 따라서 `newMember.equals(refMember)`의 결과는 `true`를 기대했지만 실행해보면 `false`가 나오면서 테스트에 실패한다. 이 테스트를 프록시가 아닌 원본 엔티티를 조회해서 비교하면 성공한다.

프록시와 `equals()` 비교를 할 때는 몇가지 주의점이 있다.
```java
if(this.getClass() != obj.getClass()) return false;
```
1. 여기서 타입을 동일성(==) 비교한다.   
앞서 프록시는 원본을 상속받은 자식 타입이므로 프록시의 타입을 비교할 때는 `==` 비교가 아닌 **`instanceof`를 사용**해야 한다고 설명했다.   
따라서 아래와 같이 변경해야 한다.
    ```java
    if(!(obj instanceof Member)) return false;
    ```
```java
Member member = (Member) obj; //member는 프록시다.

if(name != null ? !name.equals(member.name) : member.name != null){
    return false;
}
```
2. `member.name`을 보면 프록시의 멤버변수에 직접 접근한다.   
    <p align="center"><img src="https://i.ibb.co/8xjTm6B/image.png" width="60%"/><br>프록시 필드 직접 접근</p>

    `equals()` 메소드를 구현할 때는 일반적으로 멤버변수를 직접 비교하는데, 프록시의 경우는 문제가 된다.   
    **프록시는 실제 데이터를 가지고 있지 않다**. 따라서 프록시의 멤버변수에 직접 접근하면 아무값도 조회할 수 없기 때문에 `member.name`의 결과는 `null`이 반환되고 `equals()`는 `false`를 반환하게 된다.
    
    `name` 멤버변수가 `private`이므로 일반적인 상황에서는 프록시의 멤버변수에 직접 접근하는 문제가 발생하지 않지만 `equals()` 메소드는 자신을 비교하기 때문에 `private` 멤버변수에도 접근할 수 있다.    
    
    프록시의 데이터를 조회할 때는 **접근자를 사용**해야 한다.
    ```java
    Member member = (Member) obj;

    if(name != null ? !name.equals(member.getName()) : member.getName() != null)
        return false;
    ```
    <p align="center"><img src="https://i.ibb.co/Pc1g4DN/image.png" width="60%"/><br>프록시 접근자 사용</p>

    ```java
    //equals() 수정한 전체 코드
    @Override
    public boolean equals(Object obj){
        if(this == obj) return true;
        if(!(obj instanceof Member)) return false;

        Member member = (Member) obj;

        if(name != null ? !name.equals(member.getName()) : member.getName() != null){
            return false;
        }

        return true;
    }
    ```
    수정한 코드로 테스트를 실행하면 `newMember.equals(refMember)`의 결과로 `true`가 반환되고 테스트가 성공한다.

## 📝 정리
프록시의 동등성 비교 시 주의 사항 2가지
- 프록시의 타입 비교는 `==` 비교 대신 **`instanceof`를 사용**해야 한다.
- 프록시의 멤버변수에 직접 접근하면 안 되고 대신 **접근자 메소드를 사용**해야 한다.